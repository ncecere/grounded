## 2026-01-18: Define staged ingestion contract and per-stage status model

### Summary
Implemented the staged ingestion contract with per-stage status tracking for the ingestion pipeline.

### Changes Made
1. **packages/shared/src/types/index.ts**
   - Added `IngestionStage` enum defining 6 pipeline stages: discover, fetch, extract, chunk, embed, index
   - Added `StageStatus` enum with 6 statuses: pending, in_progress, completed, failed_retryable, failed_permanent, skipped
   - Added `StageTimestamps` interface for per-stage timing
   - Added `SourceRunStatsV2` interface extending `SourceRunStats` with optional per-stage aggregate stats
   - Added `StageContracts` interface documenting inputs/outputs for each stage
   - Added `PageStageStatus` interface for tracking per-page stage status

2. **packages/shared/src/constants/index.ts**
   - Added `INGESTION_STAGES` array with ordered stages
   - Added `STAGE_MAX_RETRIES` with per-stage retry limits
   - Added `STAGE_RETRY_DELAY_MS` with per-stage retry delays

3. **packages/db/src/schema/knowledge.ts**
   - Added `currentStage` field to `sourceRunPages` table for tracking current pipeline stage
   - Added `sourceRunPageStages` table for detailed per-page stage tracking with status, timestamps, error, retryCount, and metadata

4. **packages/shared/src/types/ingestion-stages.test.ts** (new file)
   - Added 60 tests covering all new types, enums, and constants
   - Tests validate type correctness, backwards compatibility, and pipeline documentation

### Acceptance Criteria Met
- ✅ Document inputs/outputs for discover, fetch, extract, chunk, embed, index (via StageContracts interface)
- ✅ Define per-stage status fields and timestamps (via IngestionStage, StageStatus, PageStageStatus, sourceRunPageStages table)
- ✅ Preserve compatibility with existing runs (SourceRunStatsV2 extends SourceRunStats, new fields are optional)

### Tests
- All 60 new tests pass
- All existing tests pass (1306 tests across all packages)
- TypeScript typechecking passes

## 2026-01-18: Standardize job payload schemas for web and upload sources

### Summary
Implemented standardized Zod schemas for all job payloads with clear distinction between web and upload sources, validation helpers, and type guards.

### Changes Made
1. **packages/shared/src/types/index.ts**
   - Added `baseJobSchema` - Zod schema for common job fields (requestId, traceId)
   - Added `webSourceJobConfigSchema` - Web source configuration (mode, fetchMode, depth, patterns, etc.)
   - Added `uploadSourceJobConfigSchema` - Upload source configuration (uploadId, filename, mimeType, sizeBytes)
   - Added `sourceJobConfigSchema` - Discriminated union of web/upload configs
   - Added `webSourceRunStartJobSchema` - Schema for starting web source runs
   - Added `webSourceDiscoverJobSchema` - Schema for URL discovery jobs
   - Added `pageFetchJobSchema` - Schema for page fetch jobs with optional parentUrl
   - Added `uploadSourceRunStartJobSchema` - Schema for starting upload source runs
   - Added `pageProcessJobSchema` - Unified schema for both web/upload with sourceType and uploadMetadata fields
   - Added `embedChunksBatchJobSchema` - Schema with optional embeddingConfig
   - Added `enrichPageJobSchema` - Schema with optional sourceType hint
   - Added `sourceRunFinalizeJobSchema` - Schema with optional sourceType
   - Added `hardDeleteObjectJobSchema` - Schema with cascade option
   - Added `kbReindexJobSchema` - Schema with deleteOldEmbeddings option
   - Added union types: `SourceRunJobPayload`, `IngestionJobPayload`, `AnyJobPayload`
   - Added `validateJobPayload()` - Throws on validation failure
   - Added `safeValidateJobPayload()` - Returns success/error result
   - Added `isWebSourcePayload()` and `isUploadSourcePayload()` type guards

2. **packages/shared/src/types/job-payloads.test.ts** (new file)
   - Added 59 tests covering all new schemas
   - Tests validate schema parsing, default values, constraints, and type compatibility
   - Tests backwards compatibility with existing payload patterns

### Key Design Decisions
- **Discriminated Union**: Used `sourceType` as discriminator to distinguish web vs upload payloads
- **Optional Extensions**: New fields (sourceConfig, uploadMetadata, embeddingConfig) are optional to maintain backwards compatibility
- **Zod Validation**: All schemas use Zod for runtime validation with TypeScript type inference
- **URL Flexibility**: `pageProcessJobSchema` accepts both HTTP URLs and `upload://` URIs

### Acceptance Criteria
- ✅ Standardized schemas for web and upload sources with clear type distinctions
- ✅ Validation schemas (Zod) for all job payloads
- ✅ Backwards compatible with existing job structures

### Tests
- All 59 new tests pass
- All existing tests pass (1306 tests across all packages)
- TypeScript typechecking passes

## 2026-01-18: Define error taxonomy with retryable vs permanent categories

### Summary
Implemented a comprehensive error classification system with retryable vs permanent error categories for the ingestion pipeline. The taxonomy enables intelligent retry decisions, proper stage status tracking, and structured error logging.

### Changes Made
1. **packages/shared/src/errors/index.ts** (new file)
   - Added `ErrorCategory` enum with 9 categories: network, service, content, configuration, not_found, validation, auth, system, unknown
   - Added `ErrorCode` enum with 35 specific error codes across all categories
   - Added `ERROR_RETRYABILITY` map classifying each error code as retryable or permanent
   - Added `ERROR_CATEGORIES` map linking error codes to their categories
   - Added `IngestionError` base class extending Error with code, category, retryable, cause, metadata, and httpStatus properties
   - Added specialized error classes: `NetworkError`, `ServiceError`, `ContentError`, `ConfigurationError`, `NotFoundError`, `ValidationError`, `AuthError`, `SystemError`
   - Added type aliases for error codes: `ServiceErrorCode`, `ContentErrorCode`, `ConfigurationErrorCode`, `NotFoundErrorCode`, `ValidationErrorCode`, `AuthErrorCode`
   - Added utility functions:
     - `isRetryableError()` - Determines if an error is retryable
     - `classifyHttpStatus()` - Maps HTTP status codes to error codes
     - `classifyError()` - Classifies generic errors into structured IngestionErrors
     - `getErrorInfo()` - Extracts error information for logging
     - `createHttpError()` - Creates appropriate error type from HTTP status

2. **packages/shared/src/index.ts**
   - Added export for the new errors module

3. **packages/shared/src/errors/errors.test.ts** (new file)
   - Added 89 tests covering all error categories, codes, and utilities
   - Tests validate retryability classification, error creation, and utility functions
   - Tests cover edge cases and error classification patterns

### Key Design Decisions
- **Retryable by default**: Network timeouts, connection errors, 5xx HTTP errors, and database errors are retryable
- **Permanent errors**: Content errors (too large, invalid format), configuration errors, validation errors, and auth errors are permanent
- **Conservative approach**: Unknown errors default to retryable to avoid dropping recoverable failures
- **Structured logging**: All errors serialize to JSON with code, category, message, retryable status, and cause

### Error Categories
| Category | Retryable | Examples |
|----------|-----------|----------|
| network | mostly yes | timeout, connection refused, DNS failure |
| service | mostly yes | rate limited, 503, 502, gateway timeout |
| content | no | too large, invalid format, empty content |
| configuration | no | missing API key, dimension mismatch |
| not_found | no | resource not found, KB not found |
| validation | no | invalid URL, schema violation |
| auth | no | unauthorized, forbidden |
| system | varies | database error (yes), disk full (no) |
| unknown | yes | unclassified errors |

### Acceptance Criteria Met
- ✅ Define error taxonomy with retryable vs permanent categories
- ✅ Comprehensive error codes for all ingestion scenarios
- ✅ Utility functions for error classification and logging

### Tests
- All 89 new tests pass
- All existing tests pass (208 tests in shared package)
- TypeScript typechecking passes

## 2026-01-18: Split queues by stage and define concurrency defaults

### Summary
Implemented a mapping between ingestion stages and queues with configurable concurrency defaults. This enables fine-grained control over parallelism at both the stage and queue level, with environment variable overrides for deployment flexibility.

### Changes Made
1. **packages/shared/src/constants/index.ts**
   - Added `STAGE_QUEUE_MAPPING` - Maps each of the 6 ingestion stages to their primary queue
   - Added `STAGE_DEFAULT_CONCURRENCY` - Default concurrency limits per stage with documented rationale
   - Added `STAGE_CONCURRENCY_ENV_VARS` - Environment variable names for per-stage concurrency overrides
   - Added `QUEUE_DEFAULT_CONCURRENCY` - Default concurrency for all 7 queues
   - Added `QUEUE_CONCURRENCY_ENV_VARS` - Environment variable names for per-queue concurrency overrides

2. **packages/shared/src/types/index.ts**
   - Added `QueueName` type for queue name type safety
   - Added `QueueConfig` interface with name, defaultConcurrency, concurrencyEnvVar, and stages fields
   - Added helper functions:
     - `getQueueForStage()` - Get queue name for a given stage
     - `getStageConcurrency()` - Get default concurrency for a stage
     - `getStageConcurrencyEnvVar()` - Get env var name for stage concurrency override
     - `getQueueConcurrency()` - Get default concurrency for a queue
     - `getQueueConcurrencyEnvVar()` - Get env var name for queue concurrency override
     - `getStagesForQueue()` - Get all stages that use a given queue
     - `buildQueueConfigMap()` - Build complete queue configuration map
     - `resolveQueueConcurrency()` - Resolve effective queue concurrency with env var support
     - `resolveStageConcurrency()` - Resolve effective stage concurrency with env var support

3. **packages/queue/src/index.ts**
   - Re-exported all new constants and helper functions for consumer convenience

4. **packages/shared/src/types/queue-config.test.ts** (new file)
   - Added 63 tests covering:
     - Stage-to-queue mapping validation
     - Concurrency defaults for all stages and queues
     - Environment variable naming conventions
     - Helper function behavior
     - Concurrency resolution with env var overrides
     - Cross-validation ensuring all stages and queues are covered

### Stage-to-Queue Mapping
| Stage | Queue | Rationale |
|-------|-------|-----------|
| discover | source-run | Orchestration stage |
| fetch | page-fetch | Network-bound, separate worker |
| extract | page-process | CPU-bound extraction |
| chunk | page-process | CPU-bound, shares with extract |
| embed | embed-chunks | API-bound embeddings |
| index | embed-chunks | Follows embedding, shares queue |

### Default Concurrency Settings
| Stage | Default | Rationale |
|-------|---------|-----------|
| discover | 2 | Low to avoid overwhelming source servers |
| fetch | 5 | Moderate for network-bound, polite to targets |
| extract | 10 | CPU-bound, parallelizable |
| chunk | 10 | Lightweight CPU-bound |
| embed | 4 | API rate limited by external providers |
| index | 8 | Database-bound, limited for connection pool |

### Environment Variables
Per-stage: `DISCOVER_CONCURRENCY`, `FETCH_CONCURRENCY`, `EXTRACT_CONCURRENCY`, `CHUNK_CONCURRENCY`, `EMBED_CONCURRENCY`, `INDEX_CONCURRENCY`

Per-queue: `SOURCE_RUN_CONCURRENCY`, `PAGE_FETCH_CONCURRENCY`, `PAGE_PROCESS_CONCURRENCY`, `EMBED_CHUNKS_CONCURRENCY`, `ENRICH_PAGE_CONCURRENCY`, `DELETION_CONCURRENCY`, `KB_REINDEX_CONCURRENCY`

### Acceptance Criteria Met
- ✅ Split queues by stage with clear mapping between stages and queues
- ✅ Define concurrency defaults with documented rationale for each stage
- ✅ Environment variable support for deployment-time overrides

### Tests
- All 63 new tests pass
- All existing tests pass (271 tests in shared package, 1306 total)
- TypeScript typechecking passes

## 2026-01-18: Add per-tenant and per-domain concurrency limits

### Summary
Implemented per-tenant and per-domain concurrency limits for the fetch/crawl pipeline. This prevents any single tenant from consuming all worker capacity and protects target servers from being overwhelmed by concurrent connections.

### Changes Made
1. **packages/shared/src/constants/index.ts**
   - Added `DEFAULT_TENANT_CONCURRENCY` (5) - Default concurrent fetch jobs per tenant
   - Added `DEFAULT_DOMAIN_CONCURRENCY` (3) - Default concurrent fetch jobs per domain
   - Added `DOMAIN_CONCURRENCY_ENV_VAR` - Environment variable for domain concurrency override
   - Added `CONCURRENCY_KEY_PREFIXES` - Redis key prefixes for tenant, domain, and tenant+domain tracking
   - Added `CONCURRENCY_KEY_TTL_SECONDS` (300) - TTL for tracking keys
   - Added `CONCURRENCY_RETRY_DELAY_MS` (5000) - Retry delay for rate-limited jobs

2. **packages/shared/src/types/index.ts**
   - Added `ConcurrencyCheckResult` interface - Result of single limit check
   - Added `CombinedConcurrencyCheckResult` interface - Combined result of all limit checks
   - Added `ActiveJobTracker` interface - Tracks active jobs for cleanup
   - Added `ConcurrencyLimitOptions` interface - Options for limit configuration
   - Added `ConcurrencyMetrics` interface - Metrics snapshot for monitoring
   - Added `extractDomainFromUrl()` - Extracts and normalizes domain from URL
   - Added `buildTenantConcurrencyKey()` - Builds Redis key for tenant tracking
   - Added `buildDomainConcurrencyKey()` - Builds Redis key for domain tracking
   - Added `buildTenantDomainConcurrencyKey()` - Builds Redis key for combined tracking
   - Added `resolveDomainConcurrency()` - Resolves domain limit with env var support
   - Added `getTenantConcurrencyLimit()` - Gets tenant limit from quotas
   - Added `createConcurrencyLimitOptions()` - Creates options from quotas and env
   - Added `getConcurrencyKeyTtl()` / `getConcurrencyRetryDelay()` - Getter helpers

3. **packages/queue/src/index.ts**
   - Added `checkTenantConcurrency()` - Checks if tenant has capacity
   - Added `checkDomainConcurrency()` - Checks if domain has capacity
   - Added `checkTenantDomainConcurrency()` - Checks combined tenant+domain limit
   - Added `checkFetchConcurrencyLimits()` - Checks all applicable limits
   - Added `acquireFetchConcurrencySlots()` - Atomically increments counters
   - Added `releaseFetchConcurrencySlots()` - Decrements counters on job completion
   - Added `getTenantActiveFetchCount()` / `getDomainActiveFetchCount()` - Monitoring helpers
   - Added `resetTenantConcurrency()` / `resetDomainConcurrency()` - Emergency cleanup
   - Added `createConcurrencyOptionsFromQuotas()` - Creates options from quotas
   - Re-exported all new constants and types

4. **packages/shared/src/types/concurrency-limits.test.ts** (new file)
   - Added 70 tests covering:
     - All concurrency constants and their values
     - Domain extraction from URLs (normalization, www removal, case handling)
     - Redis key building functions
     - Limit resolution functions with env var overrides
     - Type interface validation
     - Integration scenarios for multi-tenant domain sharing

### Key Design Decisions
- **Per-domain limits**: Applied globally across all tenants to prevent overwhelming target servers (default: 3)
- **Per-tenant limits**: Uses existing `TenantQuotas.maxCrawlConcurrency` field (default: 5)
- **Domain normalization**: Removes www prefix and lowercases for consistent tracking
- **Redis-based tracking**: Uses INCR/DECR with TTL for atomic, self-healing counters
- **Optional tenant+domain**: Allows stricter per-tenant-per-domain limits when needed

### Concurrency Limits
| Type | Default | Rationale |
|------|---------|-----------|
| Per-tenant | 5 | Prevents single tenant from consuming all capacity |
| Per-domain | 3 | Protects target servers from being overwhelmed |

### Redis Key Patterns
- Tenant: `concurrency:tenant:{tenantId}`
- Domain: `concurrency:domain:{domain}`
- Combined: `concurrency:tenant_domain:{tenantId}:{domain}`

### Environment Variables
- `DOMAIN_CONCURRENCY` - Override default per-domain limit

### Acceptance Criteria Met
- ✅ Per-tenant concurrency limits with TenantQuotas integration
- ✅ Per-domain concurrency limits to protect target servers
- ✅ Redis-based atomic tracking with TTL for auto-cleanup
- ✅ Helper functions for checking and managing limits
- ✅ Integration with existing quota system

### Tests
- All 70 new tests pass
- All existing tests pass (341 tests in shared package)
- TypeScript typechecking passes

## 2026-01-18: Implement embed lag backpressure for process queue

### Summary
Implemented embed lag backpressure for the page-process queue to prevent unbounded embed queue growth. When the embed queue depth or embed lag exceeds configurable thresholds, page-process jobs will pause before queuing more embed jobs, allowing the embed workers to catch up.

### Changes Made
1. **packages/shared/src/constants/index.ts**
   - Added `DEFAULT_EMBED_QUEUE_THRESHOLD` (100) - Queue depth threshold before backpressure
   - Added `DEFAULT_EMBED_LAG_THRESHOLD` (500) - Chunks awaiting embedding threshold
   - Added `EMBED_BACKPRESSURE_DELAY_MS` (2000) - Delay between backpressure checks
   - Added `EMBED_BACKPRESSURE_MAX_WAIT_CYCLES` (10) - Maximum wait iterations
   - Added `EMBED_BACKPRESSURE_ENV_VARS` - Environment variable names for all settings
   - Added `EMBED_BACKPRESSURE_KEY` - Redis key for tracking
   - Added `EMBED_BACKPRESSURE_KEY_TTL_SECONDS` (600) - TTL for tracking key

2. **packages/shared/src/types/index.ts**
   - Added `EmbedBackpressureCheckResult` interface - Result of backpressure check
   - Added `EmbedBackpressureConfig` interface - Configuration options
   - Added `EmbedBackpressureWaitResult` interface - Status of wait operation
   - Added `EmbedBackpressureMetrics` interface - Metrics for monitoring
   - Added `resolveEmbedBackpressureConfig()` - Resolve config from env vars
   - Added `getDefaultEmbedBackpressureConfig()` - Get default config
   - Added `checkEmbedBackpressure()` - Check if backpressure should apply
   - Added `calculateEmbedBackpressureMetrics()` - Calculate metrics for monitoring
   - Added `getEmbedBackpressureKey()` / `getEmbedBackpressureKeyTtl()` - Helper getters

3. **packages/queue/src/index.ts**
   - Added `getEmbedBackpressureConfig()` - Get cached config
   - Added `resetEmbedBackpressureConfigCache()` - Reset config cache for testing
   - Added `getEmbedQueueDepth()` - Get current embed queue depth from BullMQ
   - Added `getEmbedQueueDepthFromRedis()` - Fallback Redis-based counter
   - Added `incrementEmbedQueueDepth()` / `decrementEmbedQueueDepth()` - Counter operations
   - Added `resetEmbedQueueDepth()` - Reset counter (for testing/emergency)
   - Added `checkCurrentEmbedBackpressure()` - Check backpressure with live metrics
   - Added `waitForEmbedBackpressure()` - Wait loop for backpressure to clear
   - Added `getEmbedBackpressureMetrics()` - Get metrics for monitoring
   - Re-exported all new types and constants from @grounded/shared

4. **apps/ingestion-worker/src/processors/page-process.ts**
   - Added import for backpressure functions
   - Added backpressure check before queuing embed jobs
   - Logs backpressure wait events with timing details

5. **packages/shared/src/types/embed-backpressure.test.ts** (new file)
   - Added 54 tests covering all new types, constants, and functions
   - Tests validate configuration resolution, backpressure checks, metrics calculation
   - Tests cover edge cases and integration scenarios

### Key Design Decisions
- **Dual threshold system**: Both queue depth (pending jobs) and embed lag (chunks awaiting embedding) are checked
- **Queue depth takes priority**: If queue is full, don't add more regardless of lag
- **Configurable via env vars**: All thresholds and delays can be tuned without code changes
- **Disable option**: Can be fully disabled via `EMBED_BACKPRESSURE_DISABLED=true`
- **Max wait to avoid stalls**: Jobs won't wait forever (default 20s max)
- **Non-blocking for normal ops**: Only activates when thresholds are exceeded

### Backpressure Thresholds
| Metric | Default | Env Var | Rationale |
|--------|---------|---------|-----------|
| Queue Depth | 100 | EMBED_QUEUE_THRESHOLD | Prevents unbounded queue growth |
| Embed Lag | 500 | EMBED_LAG_THRESHOLD | Tracks chunks awaiting embedding |
| Wait Delay | 2000ms | EMBED_BACKPRESSURE_DELAY_MS | Time between recheck attempts |
| Max Cycles | 10 | EMBED_BACKPRESSURE_MAX_WAIT_CYCLES | Max wait = 20 seconds |

### Environment Variables
- `EMBED_QUEUE_THRESHOLD` - Override queue depth threshold
- `EMBED_LAG_THRESHOLD` - Override lag threshold
- `EMBED_BACKPRESSURE_DELAY_MS` - Override delay between checks
- `EMBED_BACKPRESSURE_MAX_WAIT_CYCLES` - Override max wait iterations
- `EMBED_BACKPRESSURE_DISABLED` - Set to "true" or "1" to disable

### Acceptance Criteria Met
- ✅ Implement embed lag backpressure for process queue
- ✅ Configurable thresholds via environment variables
- ✅ Logging of backpressure events for observability
- ✅ Non-blocking timeout to prevent job stalls

### Tests
- All 54 new tests pass
- All existing tests pass (395 tests in shared package)
- TypeScript typechecking passes across all packages
